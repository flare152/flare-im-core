# 接入网关与消息网关架构设计

## 概述

在 Flare IM 架构中，我们区分了两个网关服务，它们有不同的职责和部署场景：

1. **接入网关 (Access Gateway)** - `flare-access-gateway`
2. **消息网关 (Message Gateway)** - `flare-message-gateway`

---

## 架构对比

### 接入网关 (Access Gateway)

**职责**:
- 客户端连接接入管理（gRPC 接口）
- 用户认证和授权
- 会话管理（Session 管理）
- 心跳检测和连接保活
- 连接状态同步到 Online 服务

**协议**:
- gRPC（内部服务接口）
- 不直接处理客户端连接

**部署特点**:
- **多地区部署**：需要部署在不同地区，方便用户就近接入
- **无状态设计**：支持水平扩展
- **高可用**：每个地区可以部署多个实例

**使用场景**:
- 业务系统调用接入网关进行用户登录验证
- 管理用户会话状态
- 查询用户在线状态

---

### 消息网关 (Message Gateway)

**职责**:
- 客户端长连接管理（WebSocket/QUIC）
- 消息接收和推送
- 连接认证（Token 验证）
- 心跳检测和连接保活
- 消息路由和转发

**协议**:
- WebSocket
- QUIC
- TCP（可选）

**部署特点**:
- **多地区部署**：需要部署在不同地区，方便用户就近连接
- **高并发**：单实例支持 20-50万 并发连接
- **无状态设计**：支持水平扩展

**使用场景**:
- 客户端直接连接到消息网关
- 接收客户端发送的消息
- 推送消息到客户端

---

## 服务关系

```
客户端
  ↓ (WebSocket/QUIC)
消息网关 (flare-message-gateway)
  ↓ (gRPC)
接入网关 (flare-access-gateway) ← 业务系统调用
  ↓ (gRPC)
Online 服务 (flare-signaling/online)
  ↓
Route 服务 (flare-signaling/route)
  ↓
业务系统 (IM/客服/AI机器人)
```

---

## 职责划分

### 接入网关负责：

1. **认证和授权**
   - 验证用户 Token
   - 创建和管理会话
   - 设备管理

2. **会话管理**
   - Session 创建、更新、删除
   - Session 状态同步到 Redis
   - 多实例 Session 共享

3. **在线状态管理**
   - 与 Online 服务交互
   - 更新用户在线状态
   - 查询用户在线状态

4. **心跳检测**
   - 接收心跳请求
   - 更新会话活跃时间
   - 清理失效会话

### 消息网关负责：

1. **连接管理**
   - 维护客户端长连接
   - 连接认证（Token 验证）
   - 连接状态管理

2. **消息处理**
   - 接收客户端消息
   - 推送消息到客户端
   - 消息路由和转发

3. **心跳检测**
   - 自动心跳检测
   - 连接保活
   - 失效连接清理

---

## 部署架构

### 多地区部署

```
┌─────────────────────────────────────────────────────────┐
│                    华北地区（北京）                        │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐   │
│  │ 接入网关-1   │  │ 接入网关-2   │  │ 消息网关-1   │   │
│  │ 消息网关-2   │  │              │  │              │   │
│  └──────────────┘  └──────────────┘  └──────────────┘   │
└─────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────┐
│                    华东地区（上海）                        │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐   │
│  │ 接入网关-1   │  │ 接入网关-2   │  │ 消息网关-1   │   │
│  │ 消息网关-2   │  │              │  │              │   │
│  └──────────────┘  └──────────────┘  └──────────────┘   │
└─────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────┐
│                    华南地区（广州）                        │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐   │
│  │ 接入网关-1   │  │ 接入网关-2   │  │ 消息网关-1   │   │
│  │ 消息网关-2   │  │              │  │              │   │
│  └──────────────┘  └──────────────┘  └──────────────┘   │
└─────────────────────────────────────────────────────────┘
```

### 部署建议

1. **接入网关**
   - 每个地区部署 2-3 个实例（高可用）
   - 使用负载均衡器分发请求
   - 支持服务注册发现

2. **消息网关**
   - 每个地区部署多个实例（根据用户量）
   - 单实例支持 20-50万 并发连接
   - 使用负载均衡器分发连接

3. **信令服务**
   - Online 和 Route 服务可以集中部署
   - 或者每个地区部署少量实例（根据负载）

---

## 为什么分离？

### 1. 职责清晰

- **接入网关**：专注于认证、会话、状态管理（gRPC 服务）
- **消息网关**：专注于连接管理、消息传输（长连接服务）

### 2. 部署灵活

- **接入网关**：可以部署在业务区域，与业务系统更近
- **消息网关**：需要部署在边缘节点，离用户更近

### 3. 扩展性

- **接入网关**：按认证请求量扩展
- **消息网关**：按连接数扩展

### 4. 技术栈

- **接入网关**：gRPC 服务，适合内部服务调用
- **消息网关**：长连接服务，需要高性能网络处理

---

## 集成方式

### 业务系统调用接入网关

```rust
// 业务系统通过 gRPC 调用接入网关
let client = AccessGatewayClient::connect("http://access-gateway:50051").await?;

// 用户登录
let response = client.login(LoginRequest {
    user_id: "user123".to_string(),
    token: "token123".to_string(),
    device_id: "device123".to_string(),
    ..Default::default()
}).await?;
```

### 消息网关调用接入网关

```rust
// 消息网关在连接建立时，调用接入网关验证 Token
let client = AccessGatewayClient::connect("http://access-gateway:50051").await?;

// 验证 Token 并创建会话
let response = client.login(LoginRequest {
    user_id: user_id,
    token: token,
    device_id: device_id,
    ..Default::default()
}).await?;
```

---

## 总结

- **接入网关** (`flare-access-gateway`)：独立的接入层服务，负责认证、会话管理
- **消息网关** (`flare-message-gateway`)：独立的连接层服务，负责客户端连接和消息传输
- 两者职责清晰，可以独立部署和扩展
- 支持多地区部署，方便用户就近接入

